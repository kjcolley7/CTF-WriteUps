/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2014 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>
#include "crapsemu.h"


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
// ssize_t __fastcall write(int fd, char *data, size_t size);
// void *__fastcall mmap(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// ssize_t __fastcall read(int fd, char *data, size_t size);
// void *memcpy(void *dest, const void *src, size_t n);
// void __noreturn exit(int status);
signed int sub_555555555110();
void __cdecl fetch_instruction();
void __fastcall execute_instruction();
void exec_syscall(void);
void __cdecl exec_opcode(Opcode op, Register rx, Register ry, Register rz);
void __fastcall exec_ADDs(Register rx, Register ry, Register rz, bool should_set_flags);
void __fastcall exec_ANDs(Register rx, Register ry, Register rz, bool should_set_flags);
void __fastcall exec_ORRs(Register rx, Register ry, Register rz, bool should_set_flags);
void __fastcall exec_XORs(Register rx, Register ry, Register rz, bool should_set_flags);
void __fastcall exec_SUBs(Register rx, Register ry, Register rz, bool should_set_flags);
void __fastcall exec_SHR(Register rx, Register ry, Register rz);
void __fastcall exec_SHL(Register rx, Register ry, Register rz);
void __fastcall exec_X13(Register rx, Register rz);
void __fastcall exec_X25(Register rx, Register rz);
void __fastcall exec_SL8(Register rx, Register rz);
void __cdecl init_cpu();
int __cdecl main(int argc, const char **argv, const char **envp);
int __fastcall sub_5555555561B4(unsigned int a1, __int64 a2, __int64 a3);
void term_proc();
// int _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

_DWORD off_555555557004[41] =
{
  4294961025,
  4294961077,
  4294961129,
  4294961181,
  4294961233,
  4294961370,
  4294961370,
  4294961370,
  4294961370,
  4294961370,
  4294961370,
  4294961370,
  4294961370,
  4294961279,
  4294961299,
  4294961370,
  4294961051,
  4294961103,
  4294961155,
  4294961207,
  4294961256,
  4294961370,
  4294961370,
  4294961370,
  4294961370,
  4294961370,
  4294961370,
  4294961370,
  4294961370,
  4294961370,
  4294961370,
  4294961370,
  4294961319,
  4294961336,
  4294961370,
  4294961353,
  4294961370,
  4294961370,
  4294961370,
  4294961370,
  4294961380
}; // idb
char (*off_555555558D98)[4] = &byte_5555555551C0; // weak
char (*off_555555558DA0)[4] = &byte_555555555180; // weak
char program[465] =
{
  '\0',
  '\"',
  '\0',
  '∫',
  ' ',
  '\0',
  '\0',
  '\x01',
  ':',
  '`',
  'ê',
  'Ç',
  '\x01',
  '`',
  '\'',
  '∫',
  '\0',
  '@',
  '\'',
  '¬',
  'o',
  'r',
  'd',
  '\x01',
  'w',
  '`',
  'ê',
  'Ç',
  '\x01',
  '`',
  '\'',
  '∫',
  '\0',
  '@',
  '\'',
  '¬',
  'a',
  's',
  's',
  '\x01',
  'P',
  '`',
  'ê',
  'Ç',
  '\x01',
  '`',
  '\'',
  '∫',
  '\0',
  '@',
  '\'',
  '¬',
  '\x01',
  ' ',
  '\0',
  'Ç',
  '\0',
  '@',
  'ê',
  'Ñ',
  '\0',
  '@',
  'ó',
  'Ü',
  '\n',
  ' ',
  '\0',
  'à',
  '\0',
  '\0',
  '\0',
  '@',
  '\x01',
  '@',
  '\x18',
  'Ç',
  '\0',
  '@',
  'ê',
  'Ñ',
  '\0',
  '!',
  '\0',
  'Ü',
  '\x18',
  ' ',
  '\0',
  'à',
  '\0',
  '\0',
  '\0',
  '@',
  '\0',
  '\"',
  '\0',
  '∫',
  'ï',
  '\x16',
  '2',
  '\x01',
  '>',
  '`',
  'ê',
  'Ç',
  '\x01',
  '`',
  '\'',
  '∫',
  '\0',
  '@',
  '\'',
  '¬',
  'Ø',
  '@',
  '\'',
  '\x01',
  '9',
  '`',
  'ê',
  'Ç',
  '\x01',
  '`',
  '\'',
  '∫',
  '\0',
  '@',
  '\'',
  '¬',
  '≈',
  'h',
  'w',
  '\x01',
  '<',
  '`',
  'ê',
  'Ç',
  '\x01',
  '`',
  '\'',
  '∫',
  '\0',
  '@',
  '\'',
  '¬',
  '¡',
  'j',
  'L',
  '\x01',
  ' ',
  '`',
  'ê',
  'Ç',
  '\x01',
  '`',
  '\'',
  '∫',
  '\0',
  '@',
  '\'',
  '¬',
  '´',
  '\r',
  ')',
  '\x01',
  'N',
  '`',
  'ê',
  'Ç',
  '\x01',
  '`',
  '\'',
  '∫',
  '\0',
  '@',
  '\'',
  '¬',
  '†',
  'v',
  'A',
  '\x01',
  '^',
  '`',
  'ê',
  'Ç',
  '\x01',
  '`',
  '\'',
  '∫',
  '\0',
  '@',
  '\'',
  '¬',
  '\x05',
  '\0',
  '\x18',
  'Ä',
  '',
  '7',
  '\x13',
  '\x06',
  '\r',
  '†',
  'ë',
  'å',
  '\0',
  'b',
  'ß',
  'Ä',
  '\n',
  '\0',
  '\0',
  '\"',
  '\0',
  '@',
  '\a',
  '»',
  '\x01',
  '`',
  '\a',
  '∫',
  '\x06',
  '\0',
  '\x19',
  'à',
  '\0',
  '¿',
  '\0',
  'ƒ',
  '\x01',
  '‡',
  '\0',
  'Ü',
  '\x02',
  '\0',
  '°',
  'Ä',
  '¯',
  '\xFF',
  '\xFF',
  '#',
  '\x01',
  '`',
  '\x11',
  'ä',
  'ˆ',
  '\xFF',
  '\xFF',
  '1',
  '\0',
  '@',
  '°',
  'Ä',
  '\x19',
  '\0',
  '\0',
  '\"',
  '\0',
  'b',
  'ó',
  '∫',
  'd',
  '.',
  '\n',
  '\x01',
  'r',
  '`',
  'ê',
  'Ç',
  '\x01',
  '`',
  '\'',
  '∫',
  '\0',
  '@',
  '\'',
  '¬',
  's',
  'w',
  'o',
  '\x01',
  's',
  '`',
  'ê',
  'Ç',
  '\x01',
  '`',
  '\'',
  '∫',
  '\0',
  '@',
  '\'',
  '¬',
  ' ',
  'p',
  'a',
  '\x01',
  'g',
  '`',
  'ê',
  'Ç',
  '\x01',
  '`',
  '\'',
  '∫',
  '\0',
  '@',
  '\'',
  '¬',
  'r',
  'o',
  'n',
  '\x01',
  'W',
  '`',
  'ê',
  'Ç',
  '\x01',
  '`',
  '\'',
  '∫',
  '\0',
  '@',
  '\'',
  '¬',
  '\x01',
  ' ',
  '\0',
  'Ç',
  '\0',
  '@',
  'ê',
  'Ñ',
  '\0',
  '@',
  'ó',
  'Ü',
  '\x10',
  ' ',
  '\0',
  'à',
  '\0',
  '\0',
  '\0',
  '@',
  '\x01',
  ' ',
  '\0',
  'Ñ',
  '\x1B',
  '\0',
  '\0',
  '0',
  '\0',
  'b',
  'ó',
  '∫',
  '\n',
  ' ',
  '\0',
  'Ç',
  '\x01',
  '`',
  '\'',
  '∫',
  '\0',
  '@',
  '\'',
  '¬',
  'n',
  's',
  '!',
  '\x01',
  'o',
  '`',
  'ê',
  'Ç',
  '\x01',
  '`',
  '\'',
  '∫',
  '\0',
  '@',
  '\'',
  '¬',
  'a',
  't',
  'i',
  '\x01',
  'l',
  '`',
  'ê',
  'Ç',
  '\x01',
  '`',
  '\'',
  '∫',
  '\0',
  '@',
  '\'',
  '¬',
  'a',
  't',
  'u',
  '\x01',
  'r',
  '`',
  'ê',
  'Ç',
  '\x01',
  '`',
  '\'',
  '∫',
  '\0',
  '@',
  '\'',
  '¬',
  'o',
  'n',
  'g',
  '\x01',
  'C',
  '`',
  'ê',
  'Ç',
  '\x01',
  '`',
  '\'',
  '∫',
  '\0',
  '@',
  '\'',
  '¬',
  '\x01',
  ' ',
  '\0',
  'Ç',
  '\0',
  '@',
  'ê',
  'Ñ',
  '\0',
  '@',
  'ó',
  'Ü',
  '\x11',
  ' ',
  '\0',
  'à',
  '\0',
  '\0',
  '\0',
  '@',
  '\x02',
  'Ä',
  '\x18',
  'Ñ',
  '\x02',
  ' ',
  '\0',
  'Ç',
  '\0',
  '\0',
  '\0',
  '@',
  '\0'
};
_DWORD registers[32];
uint32_t (*memory)[8192];
Flags cpu_flags;


//----- (0000555555555000) ----------------------------------------------------
int init_proc()
{
  int (**v0)(void); // rax@1

  __asm { rep nop edx }
  v0 = &_gmon_start__;
  if ( &_gmon_start__ )
    LODWORD(v0) = _gmon_start__();
  return (signed int)v0;
}
// 5555555592D0: using guessed type int _gmon_start__(void);

//----- (0000555555555080) ----------------------------------------------------
#error "555555555084: can not convert to microcode (funcsize=2)"

//----- (00005555555550E0) ----------------------------------------------------
#error "5555555550EA: positive sp value has been found (funcsize=4)"

//----- (0000555555555110) ----------------------------------------------------
signed int sub_555555555110()
{
  return 1431671288;
}

//----- (00005555555551C9) ----------------------------------------------------
void __cdecl fetch_instruction()
{
  __asm { rep nop edx }
  if ( registers[PC] < ZERO || registers[PC] > 0x1FFF )
    exit(1);
  registers[FETCH] = (*memory)[registers[PC]];
}

//----- (0000555555555215) ----------------------------------------------------
void __fastcall execute_instruction()
{
  int is_zero; // eax@29
  int is_nonzero; // eax@33
  int is_overflow; // eax@37
  int v3; // eax@41
  int v4; // eax@45
  int v5; // eax@49
  int v6; // eax@53
  int v7; // eax@57
  int v8; // eax@62
  int v9; // eax@67
  int v10; // eax@71
  int v11; // eax@75
  int v12; // eax@80
  int v13; // eax@85
  char _SF; // [sp-28h] [bp-28h]@27
  char _ZF; // [sp-27h] [bp-27h]@27
  char _CF; // [sp-26h] [bp-26h]@27
  char _VF; // [sp-25h] [bp-25h]@27
  Register regY; // [sp-24h] [bp-24h]@3
  int insn; // [sp-20h] [bp-20h]@1
  Register regZ; // [sp-1Ch] [bp-1Ch]@2
  Cond cond; // [sp-18h] [bp-18h]@27
  Register regX; // [sp-14h] [bp-14h]@2
  int will_execute; // [sp-10h] [bp-10h]@31 MAPDST
  Opcode opcode; // [sp-Ch] [bp-Ch]@2

  __asm { rep nop edx }
  insn = registers[FETCH];
  if ( registers[FETCH] >= 0 )                  // top bit means XYZ-form instruction
  {
    if ( registers[31] & 0x40000000 )           // all other bits are unused
    {
      exec_syscall();
    }
    else if ( registers[31] & 0x20000000 )
    {
      cond = (registers[31] >> 25) & 0xF;       // cond bits mask is 0x1e000000
      exec_opcode(Opcode_X25, FETCH, 0, TMP);   // branch target is PC + [bits 24:0 (sign extended)]
      _SF = cpu_flags & Flag_SF;
      _ZF = cpu_flags & Flag_ZF;
      _CF = cpu_flags & Flag_CF;
      _VF = cpu_flags & Flag_VF;
      is_zero = cond == Cond_EQUAL_or_ZERO && _ZF;
      will_execute = is_zero | (cond == Cond_ALWAYS);
      is_nonzero = cond == Cond_NOT_EQUAL_or_ZERO && !_ZF;
      will_execute |= is_nonzero;
      is_overflow = cond == Cond_OVERFLOW && _VF;
      will_execute |= is_overflow;
      v3 = cond == Cond_NOT_OVERFLOW && !_VF;
      will_execute |= v3;
      v4 = cond == Cond_NOT_NEGATIVE && !_SF;
      will_execute |= v4;
      v5 = cond == Cond_NEGATIVE && _SF;
      will_execute |= v5;
      v6 = cond == Cond_CARRY_SET && _CF;
      will_execute |= v6;
      v7 = cond == Cond_CARRY_CLEAR && !_CF;
      will_execute |= v7;
      v8 = cond == Cond_SIGNED_GREATER && !_ZF && _SF == _CF;
      will_execute |= v8;
      v9 = cond == Cond_SIGNED_LESS_OR_EQUAL && (_ZF || _SF != _CF);
      will_execute |= v9;
      v10 = cond == Cond_GREATER_OR_EQUAL && _SF == _CF;
      will_execute |= v10;
      v11 = cond == Cond_LESS && _SF != _CF;
      will_execute |= v11;
      v12 = cond == Cond_SIGNED_GREATER_again && !_ZF && _SF == _CF;
      will_execute |= v12;
      v13 = cond == Cond_SIGNED_LESS_OR_EQUAL_again && (_ZF || _SF != _CF);
      if ( v13 | will_execute )
      {
        exec_opcode(Opcode_ADD, PC, TMP, PC);
        return;
      }
    }
    else                                        // MOV immediate (shifted left by 8 bits), aka MOVT
    {
      registers[TMP] = registers[FETCH] & 0x1FFFFFF;
      exec_opcode(Opcode_SL8, TMP, 0, (Register)((registers[31] >> 24) & 0x1F));
    }
  }
  else
  {
    regZ = (registers[FETCH] >> 25) & 0x1F;     // rz = bits 29:25
    opcode = (registers[FETCH] >> 19) & 0x3F;   // opcode = bits 24:19
    regX = (registers[FETCH] >> 14) & 0x1F;     // rx = bits 18:14
    if ( registers[FETCH] & 0x2000 )            // when bit 13 is set, use immediate (bits 12:0, sign extended) for ry, othrwise, ry = bits 4:0
    {
      exec_opcode(Opcode_X13, FETCH, ZERO, TMP);// grabs bits 12:0 (13 bits) and sign extends them into r15
      regY = TMP;
    }
    else
    {
      regY = registers[FETCH] & 0x1F;
    }
    if ( (signed int)regX < 0 || (signed int)regX > 31 )
      exit(1);
    if ( (signed int)regY < 0 || (signed int)regY > 31 )
      exit(1);
    if ( (signed int)regZ < 0 || (signed int)regZ > 31 )
      exit(1);
    if ( insn & 0x40000000 )                    // bit indicating memory addressing, will do LDR or STR
    {
      exec_opcode(Opcode_ADD, regX, regY, TMP);
      if ( registers[TMP] < ZERO || registers[TMP] > 0x1FFF )
        exit(1);
      if ( opcode )                             // ADD with memory bit means LDR
      {
        if ( opcode != Opcode_SUB )             // SUB with memory bit means STR
          exit(1);
        (*memory)[registers[TMP]] = registers[regZ];
      }
      else
      {
        registers[regZ] = (*memory)[registers[TMP]];
      }
    }
    else
    {
      exec_opcode(opcode, regX, regY, regZ);
    }
  }
  ++registers[PC];
}
// 555555555215: could not find valid save-restore pair for rbp

//----- (0000555555555663) ----------------------------------------------------
// switch(r1) {
//     case 0: read(r2, &memory[r3], r4); break;
//     case 1: write(r2, &memory[r3], r4); break;
//     case 2: exit(r2);
//     default: exit(1);
// }
void exec_syscall(void)
{
  __asm { rep nop edx }
  if ( registers[Register_01] == 2 )
    exit(registers[2]);
  if ( registers[Register_01] > 2 )
LABEL_11:
    exit(1);
  if ( registers[Register_01] )
  {
    if ( registers[Register_01] != 1 )
      goto LABEL_11;
    if ( (unsigned int)(registers[Register_03] + registers[Register_04]) <= 0x1FFF )// this check is insufficient, int overflow can allow OOB accesses
      registers[Register_01] = write(           // because the size is passed to read/write, very large sizes (as would be required for overflow) are actually okay because an attacker can just send fewer bytes
                                 registers[2],
                                 (char *)&(*memory)[registers[Register_03]],// also if the memory address is unmapped, the syscall will just return an error rather than crashing
                                                // this can allow easily searching the address space
                                 (unsigned int)registers[Register_04]);
  }
  else if ( (unsigned int)(registers[Register_03] + registers[Register_04]) <= 0x1FFF )
  {
    registers[Register_01] = read(
                               registers[2],
                               (char *)&(*memory)[registers[Register_03]],
                               (unsigned int)registers[Register_04]);
  }
}
// 555555555663: could not find valid save-restore pair for rbp

//----- (000055555555573F) ----------------------------------------------------
void __cdecl exec_opcode(Opcode op, Register rx, Register ry, Register rz)
{
  __asm { rep nop edx }
  if ( op <= (unsigned int)Opcode_NOP )
  {                                             // IDA is confused, actually just switch(op) here
    switch ( (_DWORD)((char *)off_555555557004 + off_555555557004[(unsigned __int64)(unsigned int)op]) )
    {
      case Opcode_ADD:
        exec_ADDs(rx, ry, rz, 0);
        goto LABEL_19;
      case Opcode_ADDS:
        exec_ADDs(rx, ry, rz, 1);
        goto LABEL_19;
      case Opcode_AND:
        exec_ANDs(rx, ry, rz, 0);
        goto LABEL_19;
      case Opcode_ANDS:
        exec_ANDs(rx, ry, rz, 1);
        goto LABEL_19;
      case Opcode_ORR:
        exec_ORRs(rx, ry, rz, 0);
        goto LABEL_19;
      case Opcode_ORRS:
        exec_ORRs(rx, ry, rz, 1);
        goto LABEL_19;
      case Opcode_XOR:
        exec_XORs(rx, ry, rz, 0);
        goto LABEL_19;
      case Opcode_XORS:
        exec_XORs(rx, ry, rz, 1);
        goto LABEL_19;
      case Opcode_SUB:
        exec_SUBs(rx, ry, rz, 0);
        goto LABEL_19;
      case Opcode_SUBS:
        exec_SUBs(rx, ry, rz, 1);
        goto LABEL_19;
      case Opcode_SHR:
        exec_SHR(rx, ry, rz);
        goto LABEL_19;
      case Opcode_SHL:
        exec_SHL(rx, ry, rz);
        goto LABEL_19;
      case Opcode_X13:
        exec_X13(rx, rz);
        goto LABEL_19;
      case Opcode_X25:
        exec_X25(rx, rz);
        goto LABEL_19;
      case Opcode_SL8:
        exec_SL8(rx, rz);
        goto LABEL_19;
      case Opcode_05:
      case Opcode_06:
      case Opcode_07:
      case Opcode_08:
      case Opcode_09:
      case Opcode_0A:
      case Opcode_0B:
      case Opcode_0C:
      case Opcode_0F:
      case Opcode_15:
      case Opcode_16:
      case Opcode_17:
      case Opcode_18:
      case Opcode_19:
      case Opcode_1A:
      case Opcode_1B:
      case Opcode_1C:
      case Opcode_1D:
      case Opcode_1E:
      case Opcode_1F:
      case Opcode_22:
      case Opcode_24:
      case Opcode_25:
      case Opcode_26:
      case Opcode_27:
        break;
      case Opcode_NOP:
LABEL_19:
        if ( registers[0] )
          registers[0] = 0;
        return;
    }
  }
  exit(1);
}
// 55555555573F: could not find valid save-restore pair for rbp

//----- (0000555555555900) ----------------------------------------------------
void __fastcall exec_ADDs(Register rx, Register ry, Register rz, bool should_set_flags)
{
  __asm { rep nop edx }
  registers[rz] = registers[rx] + registers[ry];
  if ( should_set_flags )
  {
    if ( registers[rz] >= 0 )
      cpu_flags &= ~Flag_SF;
    else
      cpu_flags |= Flag_SF;
    if ( registers[rz] )
      cpu_flags &= ~Flag_ZF;
    else
      cpu_flags |= Flag_ZF;
    if ( registers[rx] >= 0 || registers[ry] >= 0 || registers[rz] < 0 )
      cpu_flags &= ~Flag_CF;
    else
      cpu_flags |= Flag_CF;
    if ( registers[ry] + (signed __int64)registers[rx] <= 0xFFFFFFFFLL )
      cpu_flags &= ~Flag_VF;
    else
      cpu_flags |= Flag_VF;
  }
}
// 555555555900: could not find valid save-restore pair for rbp

//----- (0000555555555AB8) ----------------------------------------------------
void __fastcall exec_ANDs(Register rx, Register ry, Register rz, bool should_set_flags)
{
  __asm { rep nop edx }
  registers[rz] = registers[ry] & registers[rx];
  if ( should_set_flags )
  {
    if ( registers[rz] >= 0 )
      cpu_flags &= ~Flag_SF;
    else
      cpu_flags |= Flag_SF;
    if ( registers[rz] )
      cpu_flags &= ~Flag_ZF;
    else
      cpu_flags |= Flag_ZF;
  }
}
// 555555555AB8: could not find valid save-restore pair for rbp

//----- (0000555555555B98) ----------------------------------------------------
void __fastcall exec_ORRs(Register rx, Register ry, Register rz, bool should_set_flags)
{
  __asm { rep nop edx }
  registers[rz] = registers[ry] | registers[rx];
  if ( should_set_flags )
  {
    if ( registers[rz] >= 0 )
      cpu_flags &= ~Flag_SF;
    else
      cpu_flags |= Flag_SF;
    if ( registers[rz] )
      cpu_flags &= ~Flag_ZF;
    else
      cpu_flags |= Flag_ZF;
  }
}
// 555555555B98: could not find valid save-restore pair for rbp

//----- (0000555555555C78) ----------------------------------------------------
void __fastcall exec_XORs(Register rx, Register ry, Register rz, bool should_set_flags)
{
  __asm { rep nop edx }
  registers[rz] = registers[ry] ^ registers[rx];
  if ( should_set_flags )
  {
    if ( registers[rz] >= 0 )
      cpu_flags &= ~Flag_SF;
    else
      cpu_flags |= Flag_SF;
    if ( registers[rz] )
      cpu_flags &= ~Flag_ZF;
    else
      cpu_flags |= Flag_ZF;
  }
}
// 555555555C78: could not find valid save-restore pair for rbp

//----- (0000555555555D58) ----------------------------------------------------
void __fastcall exec_SUBs(Register rx, Register ry, Register rz, bool should_set_flags)
{
  __asm { rep nop edx }
  registers[rz] = registers[rx] - registers[ry];
  if ( should_set_flags )
  {
    if ( registers[rz] >= 0 )
      cpu_flags &= ~Flag_SF;
    else
      cpu_flags |= Flag_SF;
    if ( registers[rz] )
      cpu_flags &= ~Flag_ZF;
    else
      cpu_flags |= Flag_ZF;
    if ( registers[rx] >= 0 || registers[ry] >= 0 || registers[rz] < 0 )
      cpu_flags &= ~Flag_CF;
    else
      cpu_flags |= Flag_CF;
    if ( (unsigned __int64)(registers[ry] + (signed __int64)registers[rx]) <= 0xFFFFFFFF )// why add?
      cpu_flags &= ~Flag_VF;
    else
      cpu_flags |= Flag_VF;
  }
}
// 555555555D58: could not find valid save-restore pair for rbp

//----- (0000555555555F11) ----------------------------------------------------
void __fastcall exec_SHR(Register rx, Register ry, Register rz)
{
  __asm { rep nop edx }
  registers[rz] = registers[rx] >> registers[ry];
}

//----- (0000555555555F70) ----------------------------------------------------
void __fastcall exec_SHL(Register rx, Register ry, Register rz)
{
  __asm { rep nop edx }
  registers[rz] = registers[rx] << registers[ry];
}

//----- (0000555555555FCF) ----------------------------------------------------
// Sign extends a 13-bit value to 32 bits
void __fastcall exec_X13(Register rx, Register rz)
{
  __asm { rep nop edx }
  registers[rz] = 0xFFFFE000 * ((registers[rx] >> 12) & 1) ^ registers[rx] & 0x1FFF;
}

//----- (0000555555556042) ----------------------------------------------------
void __fastcall exec_X25(Register rx, Register rz)
{
  __asm { rep nop edx }
  registers[rz] = 0xFE000000 * ((registers[rx] >> 24) & 1) ^ registers[rx] & 0x1FFFFFF;
}

//----- (00005555555560B5) ----------------------------------------------------
void __fastcall exec_SL8(Register rx, Register rz)
{
  __asm { rep nop edx }
  registers[rz] = registers[rx] << 8;
}

//----- (00005555555560F9) ----------------------------------------------------
void __cdecl init_cpu()
{
  __asm { rep nop edx }
  memory = (uint32_t (*)[8192])mmap(NULL, 0x8000LL, 3LL, 34LL, 0LL, 0LL);
  if ( !memory )
    exit(1);
  memcpy(memory, program, 465uLL);
  registers[0] = 0;
  registers[Register_14] = 1;
}

//----- (0000555555556179) ----------------------------------------------------
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  init_cpu();
  while ( 1 )
  {
    fetch_instruction();
    execute_instruction();
  }
}

//----- (00005555555561B4) ----------------------------------------------------
int __fastcall sub_5555555561B4(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r14@1
  int result; // eax@1
  signed __int64 v5; // rbp@1
  __int64 v6; // rbx@2

  v3 = a3;
  result = init_proc();
  v5 = &off_555555558DA0 - &off_555555558D98;
  if ( v5 )
  {
    v6 = 0LL;
    do
      result = ((int (__fastcall *)(_QWORD, __int64, __int64))(&off_555555558D98)[2 * v6++])(a1, a2, v3);
    while ( v5 != v6 );
  }
  return result;
}
// 555555558D98: using guessed type char (*off_555555558D98)[4];
// 555555558DA0: using guessed type char (*off_555555558DA0)[4];

//----- (0000555555556228) ----------------------------------------------------
void term_proc()
{
  __asm { rep nop edx }
}

#error "There were 2 decompilation failure(s) on 22 function(s)"
